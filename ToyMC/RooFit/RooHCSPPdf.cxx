#include <iostream>
#include <iomanip>

#include <math.h>
#include "StoppedHSCP/Lumi/interface/LumiReader.h"
#include "StoppedHSCP/Lumi/interface/LumiDecayMC.h"
/***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooHCSPPdf.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 
 #include "RooRandom.h" 

using namespace shscp;


 ClassImp(RooHCSPPdf) 

   RooHCSPPdf::RooHCSPPdf(const char *name, const char *title, 
			  RooAbsReal& _t,
			  RooAbsReal& _logtau,
			  const std::string& lumiFile)
     : RooAbsPdf(name,title),
       t("t","t",this,_t),
       logtau("logtau","logtau",this,_logtau),
       mLumiFileName (lumiFile),
       mLumiReader (LumiReader::getLumiReader (mLumiFileName)),
       mLumiDecayMC (LumiDecayMC::getLumiDecayMC (mLumiReader)),
       mCacheIntegral (-1),
       mCacheTmin (0),
       mCacheTmax (0)
{ 
  //  std::cout << "RooHCSPPdf::RooHCSPPdf()->" << this << std::endl;
} 

RooHCSPPdf::~RooHCSPPdf () {
}

RooHCSPPdf::RooHCSPPdf(const RooHCSPPdf& other, const char* name) :  
  RooAbsPdf(other,name), 
  t("t",this,other.t),
  logtau("logtau",this,other.logtau),
  mLumiFileName (other.mLumiFileName),
  mLumiReader (other.mLumiReader),
  mLumiDecayMC (other.mLumiDecayMC),
  mCacheIntegral (other.mCacheIntegral),
  mCacheTmin (other.mCacheTmin),
  mCacheTmax (other.mCacheTmax)
{
  //  std::cout << "RooHCSPPdf::RooHCSPPdf(RooHCSPPdf)->" << this << std::endl;
} 

RooHCSPPdf& RooHCSPPdf::operator=(const RooHCSPPdf& other) {
  t = other.t;
  logtau = other.logtau;
  mLumiFileName = other.mLumiFileName;
  mLumiReader = other.mLumiReader;
  mLumiDecayMC = other.mLumiDecayMC;
  mCacheIntegral = other.mCacheIntegral;
  mCacheTmin = other.mCacheTmin;
  mCacheTmax = other.mCacheTmax;
  //  std::cout << "RooHCSPPdf::operator=->" << this << std::endl;
  return *this;
} 



namespace {
  const double HISTORY_MARGIN = log (1.e5);

  // helper function to evaluate integral of contribution from particular section
  double makeIntegral (double fTime, LumiReader& fLumiReader, int64_t fIndex, const std::vector<uint32_t>& fAllTimestamps, double fLifetime) {
    double result = 0;
    double t0 = fLumiReader.sectionStartTime (fIndex);
    if (fTime < t0) return 0; // past time
    double t1 = fLumiReader.sectionEndTime (fIndex);
    double thisSectionFraction = fLumiReader.sectionEmptyBunchesFraction (fIndex);
    if (fTime <= t1) {  // current section
      result = ((fTime-t0) - fLifetime*(1.-exp(-(fTime-t0)/fLifetime))) * thisSectionFraction;
    }
    else {
      result = ((t1-t0) - fLifetime*(1.-exp(-(t1-t0)/fLifetime))) * thisSectionFraction; // integral over the section itself
      // have to normalize yield of every section
      double scale = fLifetime*(1.-exp(-(t1-t0)/fLifetime));
      int timeIndex = 0;
      for (; timeIndex < int (fAllTimestamps.size()); ++timeIndex) {
	if (fAllTimestamps [timeIndex] > 0.5*(t0+t1)) break; // index of the current section
      }
      timeIndex++; // first following section
      if (timeIndex >= int (fAllTimestamps.size()))  return 0; // time after last section
      for (; timeIndex < int (fAllTimestamps.size()); ++timeIndex) {
	// contribution of the runsection
	if (fAllTimestamps[timeIndex] > t1 + HISTORY_MARGIN*fLifetime) break; // too far away
	if (timeIndex > 0 && fAllTimestamps[timeIndex-1] > fTime) break; // beyond integration period
	int64_t index = fLumiReader.getIndex (fAllTimestamps[timeIndex]);
	if (index < 0) {
	  std::cerr << "RooHCSPPdf::analyticalIntegral-> Can not get data for time " << fAllTimestamps[timeIndex];
	}
	double tIntegralMin = fLumiReader.sectionStartTime (index);
	double tIntegralMax = fLumiReader.sectionEndTime (index);
	if (tIntegralMax > fTime) tIntegralMax = fTime;
	double fraction = fLumiReader.sectionEmptyBunchesFraction (index);
	
	result += scale * (exp(-(tIntegralMin-t1)/fLifetime) - exp(-(tIntegralMax-t1)/fLifetime)) * fraction;
      }
    }
    return result;
  }
  
}

double RooHCSPPdf::integratedEffectiveLumi (double fTMin, double fTMax) const {
  if (mCacheIntegral >= 0 && mCacheTmin == fTMin && mCacheTmax == fTMax) return mCacheIntegral;
  double tMin = fTMin;
  double tMax = fTMax;
  Double_t lifetime = exp (logtau);
  std::vector<uint32_t> allTimestamps = mLumiReader->getAllTimestamps ();
  double result = 0;
  for (int64_t index = 0; index < mLumiReader->entries(); ++index) {
    double t0 = mLumiReader->sectionStartTime (index);
    if (tMin < t0 && tMax < t0) continue;
    double instant_lumi =  mLumiReader->instantLuminosity (index);
    if (instant_lumi <= 0.) continue; // no contribution from this section
    double integralMin = tMin > t0 ? makeIntegral (tMin, *mLumiReader, index, allTimestamps, lifetime) : 0;
    double integralMax = tMax > t0 ? makeIntegral (tMax, *mLumiReader, index, allTimestamps, lifetime) : 0;
    result += instant_lumi * (integralMax - integralMin);
   }
   //   std::cout << "RooHCSPPdf::analyticalIntegral " << this << " -> " << setprecision(12) << tMin << '/' << tMax << setprecision(6) << '/' << lifetime << '/' << result << std::endl;
  mCacheIntegral = result;
  mCacheTmin = fTMin;
  mCacheTmax = fTMax;

  return result;
}


 Double_t RooHCSPPdf::evaluate() const 
 { 
   Double_t current_time = t;
   Double_t lifetime = exp (logtau);
   double dndt = 0;
   std::vector<uint32_t> timestamps = mLumiReader->getAllTimestamps ();
   for (size_t i = 0; i < timestamps.size (); ++i) {
     uint32_t timestamp1 = timestamps [i];
     uint32_t timestamp0 = timestamp1 > 200 ? timestamp1 - 200 : 0; // pessimistic estimation for runsection length
     if (current_time < timestamp0) continue;
     if (current_time > timestamp1 + HISTORY_MARGIN*lifetime) continue;
     int64_t index = mLumiReader->getIndex (timestamp1);
     double t0 = mLumiReader->sectionStartTime (index);
     if (current_time < t0) continue;
     double t1 = mLumiReader->sectionEndTime (index);
     double instant_lumi =  mLumiReader->instantLuminosity (index);
     if (current_time < t1) {
       dndt += instant_lumi * (1.-exp(-(current_time-t0)/lifetime));
     }
     else {
       dndt += instant_lumi * (1.-exp(-(t1-t0)/lifetime)) * exp (-(current_time-t1)/lifetime);
     }
   }
   // look for current runsection
   int64_t currentIndex = mLumiReader->getIndex (current_time);
   dndt *= currentIndex >= 0 ? mLumiReader->sectionEmptyBunchesFraction (currentIndex) : 0;
   // std::cout << "RooHCSPPdf::evaluate()->" << setprecision(12) << current_time << setprecision(6) << '/' << lifetime << '/' << dndt << std::endl;
   return dndt;
 } 

Int_t RooHCSPPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{
  //return 0;
  if (matchArgs(allVars,analVars,t)) return 1 ;
  return 0 ;
}

Double_t RooHCSPPdf::analyticalIntegral(Int_t code, const char* rangeName) const 
{
  assert(code==1);
//   std::cout << "RooHCSPPdf::analyticalIntegral-> " << this << '/' 
// 	    << setprecision(12) << t.min(rangeName) << '/' << t.max(rangeName) << std::endl;

  return integratedEffectiveLumi (t.min(rangeName), t.max(rangeName));
}

Int_t RooHCSPPdf::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const
{
  if (matchArgs(directVars,generateVars,t)) return 1 ;  
  return 0 ;
}

void RooHCSPPdf::generateEvent(Int_t code)
{
  assert(code==1) ;
  Double_t lifetime = exp (logtau);
  Double_t tgen = mLumiDecayMC->generate (t.min(), t.max(), lifetime);
  t = tgen ;
  // std::cout << "RooHCSPPdf::generateEvent-> " << setprecision(12) << tgen << setprecision(6) << std::endl;
  return;
}

// ====================== RooHCSPBkgPdf ============================

ClassImp(RooHCSPBkgPdf) 
  
  RooHCSPBkgPdf::RooHCSPBkgPdf(const char *name, const char *title, 
			       RooAbsReal& _t,
			       const std::string& lumiFile)
    : RooAbsPdf(name,title),
      t("t","t",this,_t),
      mLumiFileName (lumiFile),
      mLumiReader (LumiReader::getLumiReader (mLumiFileName)),
      mLumiDecayMC (LumiDecayMC::getLumiDecayMC (mLumiReader)),
      mCacheIntegral (-1),
      mCacheTmin (0),
      mCacheTmax (0)

{ 
} 

RooHCSPBkgPdf::~RooHCSPBkgPdf () {
}

RooHCSPBkgPdf::RooHCSPBkgPdf(const RooHCSPBkgPdf& other, const char* name) :  
  RooAbsPdf(other,name), 
  t("t",this,other.t),
  mLumiFileName (other.mLumiFileName),
  mLumiReader (other.mLumiReader),
  mLumiDecayMC (other.mLumiDecayMC),
  mCacheIntegral (other.mCacheIntegral),
  mCacheTmin (other.mCacheTmin),
  mCacheTmax (other.mCacheTmax)

{
} 

RooHCSPBkgPdf& RooHCSPBkgPdf::operator=(const RooHCSPBkgPdf& other) {
  t = other.t;
  mLumiFileName = other.mLumiFileName;
  mLumiReader = other.mLumiReader;
  mLumiDecayMC = other.mLumiDecayMC;
  mCacheIntegral = other.mCacheIntegral;
  mCacheTmin = other.mCacheTmin;
  mCacheTmax = other.mCacheTmax;
  return *this;
} 

double RooHCSPBkgPdf::integratedEffectiveRateCorrection (double fTMin, double fTMax) const {
  if (mCacheIntegral >= 0 && mCacheTmin == fTMin && mCacheTmax == fTMax) return mCacheIntegral;
  double tMin = fTMin;
  double tMax = fTMax;
  double result = 0;
  for (int64_t index = 0; index < mLumiReader->entries(); ++index) {
    double t0 = mLumiReader->sectionStartTime (index);
    if (tMin < t0 && tMax < t0) continue;
    double t1 = mLumiReader->sectionEndTime (index);
    if (tMin > t1 && tMax > t1) continue;
    
    double fraction =  mLumiReader->sectionEmptyBunchesFraction (index);
    double integralTMin = tMin > t0 ? tMin : t0;
    double integralTMax = tMax < t1 ? tMax : t1;
    result += integralTMin < integralTMax ? fraction * (integralTMax-integralTMin) : 0;
  }
  //  std::cout << "RooHCSPBkgPdf::analyticalIntegral-> " << setprecision(12) << tMin << '/' << tMax << setprecision(6) << '/' << result << std::endl;
  
  result = tMin != tMax ? result / (tMax - tMin) : 0;
  mCacheIntegral = result;
  mCacheTmin = fTMin;
  mCacheTmax = fTMax;
  return result;
}

Double_t RooHCSPBkgPdf::evaluate() const 
{ 
  Double_t current_time = t;
  int64_t currentIndex = mLumiReader->getIndex (current_time);
  return currentIndex >= 0 ? mLumiReader->sectionEmptyBunchesFraction (currentIndex) : 0;
} 

Int_t RooHCSPBkgPdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
{
  if (matchArgs(allVars,analVars,t)) return 1 ;
  return 0 ;
}

Double_t RooHCSPBkgPdf::analyticalIntegral(Int_t code, const char* rangeName) const 
{
  assert(code==1);
  
  double tMin = t.min(rangeName);
  double tMax = t.max(rangeName);
//   std::cout << "RooHCSPBkgPdf::analyticalIntegral-> " << this << '/'
// 	    << setprecision(12) << tMin << '/' << tMax << std::endl;
  return integratedEffectiveRateCorrection (tMin, tMax) * (tMax - tMin);
}

Int_t RooHCSPBkgPdf::getGenerator(const RooArgSet& directVars, RooArgSet &generateVars, Bool_t /*staticInitOK*/) const
{
  if (matchArgs(directVars,generateVars,t)) return 1 ;  
  return 0 ;
}

void RooHCSPBkgPdf::generateEvent(Int_t code)
{
  assert(code==1) ;
  Double_t tgen = mLumiDecayMC->generateFlat (t.min(), t.max());
  t = tgen;
  // std::cout << "RooHCSPBkgPdf::generateEvent-> " << setprecision(12) << tgen << setprecision(6) << std::endl;
 return;
}

